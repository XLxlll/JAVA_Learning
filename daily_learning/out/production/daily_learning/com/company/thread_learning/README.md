#多线程与高并发
##进程
### 锁
#### 对象锁
#### 类锁
### 进程之间如何通信
1.一个进程无法访问另一个进程的变量和数据结构
## 线程
###创建线程的三种方式
1.
2.
3.

### 启动线程的三种方式
1.Thread
2.Runnable
3.Executors.newCachedThreadPool()--线程池，
### 方法
1.sleep() ---常用于模拟让一个正在执行的线程停止几毫秒，让其他线程来运行；执行sleep()的线程，等待几毫秒，让给别的线程执行，设置的时间过去复活。
2.yield() ---执行yield()线程让出一下cpu，进入等待队列，让给别的线程执行（但是不能保证其他线程一定能抢到cpu，也可能该线程刚进入等待队列，又被拿出来继续执行）
3.join() --- 线程A运行中调用线程B的join()，那么线程A就会等待线程B执行完成之后才会执行，线程A调用自己的join()方法是没有意义的，面试题如何做到一个线程执行完成另一个线程才能执行
4.getState() ---线程的状态
5.run() ---当做普通方法的方式调用
6.start()---new创建一个Thread对象，此时线程的状态是新建，start()启动线程，真正实现了多线程运行，线程进入runnable状态,cpu在队列中选中该线程，此时才进入线程的running状态
调用sleep(),wait()，进行某个阻塞的io操作，获取某个锁资源---线程进入BLOCKED状态；TERMINATED状态线程生命周期结束
### synchronized () 
Hotspot 实现
synchronized () --可以对什么锁定？
1.Object o = new Object(); synchronized (o) --锁定某个对象，注意这个锁对象不能变，加final修饰，一旦锁对象发生变化，锁就无意义了，但是锁对象的属性可以变化
2.synchronized (this) = public synchronized void m() 与synchronized修饰的非静态方法等值,一个类中两个方法中同时有synchronized (this)，一个线程拿到锁会阻塞其他带synchronized (this)的方法
3.static 方法没有this对象，因为不需要创建对象，synchronized(x.class)
4.加了synchronized就没必要加volatile，因为synchronized既保证了一致性又保证了可见性，volatile只有可见性
5.同步方法（加了synchronized的）和非同步方法可以一起调用
6.面试题：模拟银行账户，对业务写方法加锁，读方法不加锁，这样行不？取决于银行业务，不加的话容易产生脏读，写的话加锁效率会非常低
7.一个同步方法可调用另一个同步方法，加的是同一把锁，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁，synchronized获得的锁是可重入，否则会产生死锁，父子类，
8.程序中出现异常，锁默认被释放
9.底层实现
    JDK早期--重量级，需要OS
    锁升级-- 第一个线程A访问的时候，不加锁，只是markword（记录这个线程A的ID）-->偏向锁（若下次来的还是线程A，直接锁住）
    如果有线程B争用--升级为 自旋锁（占CPU ，不访问OS，什么时候用自旋锁[执行线程短（加锁代码），线程个数少]，什么时候用重量锁[执行时间长的线程、线程个数多]） 线程B默认自旋10次（10圈过程中，若A释放了锁）
    10次之后还没得到，升级为重量锁 --OS（不占CPU，线程B进入等待队列，）
    --锁只能升级，不能降级
10.不能用String常量，Integer，Long
11.优化
    锁粒度要小，--锁细化
    锁粗化 -- 若细化的太多，就需要进行粗化，否则加锁太多影响效率
### volatile

### CAS（无锁优化 自旋）

### 
不要关闭线程（stop()慎用，会造成状态不一致）--正常结束线程
在java里创建n个线程，操作系统里的线程数量不确定（大于n），取决于虚拟机，因为虚拟机还要起一些线程
interrupt()，需要catch异常，后续运行取决于自己的代码

